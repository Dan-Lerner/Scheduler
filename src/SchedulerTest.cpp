//============================================================================
// Name        : SchedulerTest.cpp
// Author      : Dan Lerner
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <chrono>
#include <thread>

#include "Scheduler/Timer.h"
#include "Scheduler/Scheduler.h"
#include "Scheduler/FileContext.h"

using namespace std;
using namespace Timework;
using namespace std::chrono;

Timer timer;
Scheduler scheduler;
Calendar calendar;

// Here is the test of Timer and Scheduler functionality
// Timer and Scheduler are platform independent set of classes
// And they don't use the heap (important for embedded sw)
////////////////////////////////////////////////////////////////////////////

// Prints time in seconds since epoch using time format
void GetTimeStr(char* str, TIME timeSec)
{
	CALENDAR_TIME time;
	calendar.SecToDateTimeEpoch(timeSec, &time);

	::sprintf(str,
			"%04d.%02d.%02d %02d:%02d:%02d",
			time.timePar[CALENDAR_TIME::YEAR],
			time.timePar[CALENDAR_TIME::MONTH],
			time.timePar[CALENDAR_TIME::DAY],
			time.timePar[CALENDAR_TIME::HOUR],
			time.timePar[CALENDAR_TIME::MIN],
			time.timePar[CALENDAR_TIME::SEC]);
}

// Prints sequence of events for specified filter and time
void ShowScheduledSequence(const CALENDAR_TIME& timeStart, const SCHEDULER_EVENT_FILTER& filter, int eventsN = 5)
{
	TIME timeSec = calendar.DateTimeToSecEpoch(&timeStart);
	char strOut[20];

	// Normalizes start time to closest sequence value
	scheduler.GetNextEvent(&filter, &timeSec, true);

	// Sequence printing
	for (int ii = 0; ii < eventsN; ii++)
	{
		GetTimeStr(strOut, timeSec);

		cout << strOut << std::endl;

		// Main filter procedure
		if (!scheduler.GetNextEvent(&filter, &timeSec))
		{
			return;
		}
	}
}

int main()
{
	// Timer test
	//-----------------
	//

	// Initialization of memory for timer table
	int timerTableSize = timer.GetTableBinSize(5);
	void* pTimerTable = ::alloca(timerTableSize);
	timer.SetTableMem(pTimerTable, timerTableSize);

	// Current time in milliseconds since epoch
	auto timePoint = system_clock::now();
	auto start = duration_cast<milliseconds>(timePoint.time_since_epoch()).count();

	cout << "TimersCount=" << timer.GetTimersCount() << std::endl;

	TIMER_SET timerSet;

	// Sets timer signals handler
	timerSet.fpPT = [](TIMER_TICK* pTick) -> bool {

		cout << "TimerID=" << pTick->ID << " SignalTime=" << pTick->time << " CheckTime=" <<
				pTick->timeCurrent << " TimersCount=" << timer.GetTimersCount();

		if (pTick->lost)
		{
			cout << " (Lost Signal)";
		}

		cout << std::endl;

		return true;
	};

	// Initializes timer with period of 100ms
	timerSet.timeStart = start;
	timerSet.timePeriod = 100;
	timerSet.timeBind = 0;
	timerSet.signalsN = 5;
	timerSet.flags = TIMER_SET::FLAG_BIND | TIMER_SET::FLAG_PROCESS_LOST;

	// Charges Timer
	timer.SetTimer(&timerSet, start);

	cout << "TimersCount=" << timer.GetTimersCount() << std::endl;

	// Initializes timer with period of 3s binded to 1500 value
	timerSet.timePeriod = 3000;
	timerSet.timeBind = 1500;
	timerSet.signalsN = 3;
	timerSet.flags = TIMER_SET::FLAG_BIND | TIMER_SET::FLAG_PROCESS_LOST;

	// Charges Timer
	timer.SetTimer(&timerSet, start);

	// For timers processing we must periodically call CheckTimers
	// with current system time in milliseconds (depends on required precision)
	auto time = start;
	while (time - start < 12'000)
	{
		// Current time
		timePoint = system_clock::now();
		time = duration_cast<milliseconds>(timePoint.time_since_epoch()).count();

		// Checks if there are timers to fire
		timer.CheckTimers(time);

		// Emulates checking interval
		this_thread::sleep_for(153ms);
	}

	cout << "TimersCount=" << timer.GetTimersCount() << std::endl;
	cout << std::endl;

	// Scheduler filter test
	//----------------------
	//

	// Filter is the main part of Scheduler functionality
	// It defines algorithms for event sequences generation using SCHEDULER_EVENT_FILTER
	// Sequences are generated by Scheduler::GetNextEvent method (see ShowScheduledSequence)

	// Associates calendar with scheduler
	scheduler.SetCalendar(&calendar,
			Scheduler::EPOCH1970_YEAR,
			Scheduler::EPOCH1970_MONTH,
			Scheduler::EPOCH1970_DAY);

	// Start date-time for filter processing
	CALENDAR_TIME timeStart = { { 2, 38, 11, 7, -1, 3, 2023 } };

	SCHEDULER_EVENT_FILTER filter;

	cout << "This filter generates events every weekend (Sat and Sun) at 2pm and 8pm" << std::endl;

	filter.year.NotUsed();
	filter.month.NotUsed();
	filter.week.AnyTime();
	filter.day.Span(CALENDAR_TIME::SAT, CALENDAR_TIME::SUN, 1);
	filter.hour.Span(14, 20, 6);
	filter.min.NotUsed();
	filter.sec.NotUsed();

	ShowScheduledSequence(timeStart, filter);
	cout << std::endl;

	cout << "This filter generates events every 29.02.XXXX at 10:15am" << std::endl;

	filter.year.Span(2023, 2039, 1);
	filter.month.Value(CALENDAR_TIME::FEB);
	filter.week.NotUsed();
	filter.day.Value(29);
	filter.hour.Value(10);
	filter.min.Value(15);
	filter.sec.NotUsed();

	ShowScheduledSequence(timeStart, filter);
	cout << std::endl;

	cout << "This filter generates events every 31.XX.2025 at 00:00" << std::endl;

	filter.year.Value(2025);
	filter.month.AnyTime();
	filter.week.NotUsed();
	filter.day.Value(31);
	filter.hour.NotUsed();
	filter.min.NotUsed();
	filter.sec.NotUsed();

	ShowScheduledSequence(timeStart, filter);
	cout << std::endl;

	// Scheduler test
	//---------------
	//

	cout << "In this example events will be generated" << endl;
	cout << "- On odd days of month every odd minute" << endl;
	cout << "- On even days of month every even minute" << endl;

	// ID for events handling
	static const int eventID1 = 1;
	static const int eventID2 = 2;

	// Associates Timer object with Scheduler
	scheduler.SetTimer(&timer, [](TIMER_TICK* pTick) -> bool {
		return scheduler.ProcessTimer(pTick);
	});

	// Sets event handler
	scheduler.SetEventDispather([](SCHEDULER_EVENT* pEvent) -> bool {

		char strOut[20];

		GetTimeStr(strOut, pEvent->time);
		cout << "EventID=" << pEvent->ID << " SignalTime=" << strOut;

		GetTimeStr(strOut, pEvent->timeCurrent);
		cout << " CheckTime=" << strOut;

		if (pEvent->lost)
		{
			cout << " (Lost event)";
		}

		cout << std::endl;

		return true;
	});

	// Current time in seconds since epoch for events initialization
	auto timeStartSec = duration_cast<seconds>(timePoint.time_since_epoch()).count();

	// Initializes file for Scheduler table
	// For other storage types (EEPROM, FRAM etc)
	// you need to implement corresponding context using IContext
	FileContext file("scheduler.tbl");
	bool contextExist = file.IsExist();

	// If a table already exists Scheduler object is initialized
	// with records from the table if any
	// Else table is initialized with empty records
	scheduler.InitTable(&file, timeStartSec, 5);

	if (!contextExist)
	{
		// New events is added only in new table
		// If you want to change these events
		// first delete "scheduler.tbl" file in working directory
/*
		SCHEDULER_EVENT_SET event;

		event.ID = eventID1;
		event.timeStart = timeStartSec;
		event.filter.year.NotUsed();
		event.filter.month.AnyTime();
		event.filter.week.NotUsed();
		event.filter.day.Span(1, TF_RANGE::NO_LIMIT, 1);
		event.filter.hour.AnyTime();
		event.filter.min.Span(1, TF_RANGE::NO_LIMIT, 2);
		event.filter.sec.NotUsed();
		event.eventsN = SCHEDULER_EVENT_SET::INFINITE;
		event.flags = SCHEDULER_EVENT_SET::FLAG_PROCESS_LOST;

		scheduler.SetEvent(&event, timeStartSec);

		event.ID = eventID2;
		event.timeStart = timeStartSec;
		event.filter.year.NotUsed();
		event.filter.month.AnyTime();
		event.filter.week.NotUsed();
		event.filter.day.Span(1, TF_RANGE::NO_LIMIT, 1);
		event.filter.hour.AnyTime();
		event.filter.min.Span(1, TF_RANGE::NO_LIMIT, 1);
		event.filter.sec.Value(30);
		event.eventsN = SCHEDULER_EVENT_SET::INFINITE;
		event.flags = SCHEDULER_EVENT_SET::FLAG_IGNORE_LOST;

		scheduler.SetEvent(&event, timeStartSec);
*/
		SCHEDULER_EVENT_SET event;

		event.ID = eventID1;
		event.timeStart = timeStartSec;
		event.filter.year.NotUsed();
		event.filter.month.AnyTime();
		event.filter.week.NotUsed();
		event.filter.day.Span(1, TF_RANGE::NO_LIMIT, 2);
		event.filter.hour.AnyTime();
		event.filter.min.Span(1, TF_RANGE::NO_LIMIT, 2);
		event.filter.sec.NotUsed();
		event.eventsN = SCHEDULER_EVENT_SET::INFINITE;
		event.flags = SCHEDULER_EVENT_SET::FLAG_IGNORE_LOST;

		scheduler.SetEvent(&event, timeStartSec);

		event.ID = eventID2;
		event.timeStart = timeStartSec;
		event.filter.year.NotUsed();
		event.filter.month.AnyTime();
		event.filter.week.NotUsed();
		event.filter.day.Span(2, TF_RANGE::NO_LIMIT, 2);
		event.filter.hour.AnyTime();
		event.filter.min.Span(0, TF_RANGE::NO_LIMIT, 2);
		event.filter.sec.Value(30);
		event.eventsN = SCHEDULER_EVENT_SET::INFINITE;
		event.flags = SCHEDULER_EVENT_SET::FLAG_IGNORE_LOST;

		scheduler.SetEvent(&event, timeStartSec);
	}


	// Emulates timer checking for Schedulers events processing
	// It is not necessary to use precise timers for Scheduler
	// A period of one second is pretty enough

	timePoint = system_clock::now();
	start = duration_cast<seconds>(timePoint.time_since_epoch()).count();
	time = start;

	while (time - start < 500'000)
	{
		timePoint = system_clock::now();
		time = duration_cast<seconds>(timePoint.time_since_epoch()).count();

		timer.CheckTimers(time);

		this_thread::sleep_for(1000ms);
	}

	return 0;
}
